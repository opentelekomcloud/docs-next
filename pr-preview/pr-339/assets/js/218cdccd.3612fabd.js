"use strict";(self.webpackChunkdocs_next=self.webpackChunkdocs_next||[]).push([[4733],{28813:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"blueprints/by-use-case/observability/deploy-grafana-loki-on-cce","title":"Deploy Grafana Loki on CCE","description":"Deploying Grafana Loki on Cloud Container Engine (CCE) enables a scalable, cloud-native log aggregation and monitoring solution within the Open Telekom Cloud environment. Loki integrates seamlessly with Grafana to collect, index, and visualize log data without the high storage costs associated with traditional log management systems. By running Loki on CCE, users can take advantage of Kubernetes-native deployments, simplified scaling, and secure, managed infrastructure. This approach provides an efficient foundation for observability, supporting modern DevOps practices and improving operational insights across distributed applications.","source":"@site/docs/blueprints/by-use-case/observability/deploy-grafana-loki-on-cce.md","sourceDirName":"blueprints/by-use-case/observability","slug":"/blueprints/by-use-case/observability/deploy-grafana-loki-on-cce","permalink":"/docs-next/pr-preview/pr-339/docs/blueprints/by-use-case/observability/deploy-grafana-loki-on-cce","draft":false,"unlisted":false,"editUrl":"https://github.com/opentelekomcloud/docs-next/tree/main/docs/blueprints/by-use-case/observability/deploy-grafana-loki-on-cce.md","tags":[{"inline":true,"label":"cce","permalink":"/docs-next/pr-preview/pr-339/docs/tags/cce"},{"inline":true,"label":"observability","permalink":"/docs-next/pr-preview/pr-339/docs/tags/observability"},{"inline":true,"label":"logging","permalink":"/docs-next/pr-preview/pr-339/docs/tags/logging"},{"inline":true,"label":"grafana","permalink":"/docs-next/pr-preview/pr-339/docs/tags/grafana"},{"inline":true,"label":"loki","permalink":"/docs-next/pr-preview/pr-339/docs/tags/loki"}],"version":"current","sidebarPosition":1,"frontMatter":{"id":"deploy-grafana-loki-on-cce","title":"Deploy Grafana Loki on CCE","tags":["cce","observability","logging","grafana","loki"],"sidebar_position":1},"sidebar":"blueprintsSidebar","previous":{"title":"Observability","permalink":"/docs-next/pr-preview/pr-339/docs/blueprints/by-use-case/observability/"},"next":{"title":"Aggregate CCE Logs with Promtail & Grafana Loki","permalink":"/docs-next/pr-preview/pr-339/docs/blueprints/by-use-case/observability/aggregate-cce-logs-with-promtail-and-grafana-loki"}}');var t=i(74848),r=i(28453);const a={id:"deploy-grafana-loki-on-cce",title:"Deploy Grafana Loki on CCE",tags:["cce","observability","logging","grafana","loki"],sidebar_position:1},o="Deploy Grafana Loki on CCE",l={},c=[{value:"Architecture",id:"architecture",level:2},{value:"Installing Grafana Loki",id:"installing-grafana-loki",level:2},{value:"Verification",id:"verification",level:2}];function d(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"deploy-grafana-loki-on-cce",children:"Deploy Grafana Loki on CCE"})}),"\n",(0,t.jsxs)(n.p,{children:["Deploying ",(0,t.jsx)(n.a,{href:"https://grafana.com/docs/loki/latest/",children:"Grafana Loki"})," on Cloud Container Engine (CCE) enables a scalable, cloud-native log aggregation and monitoring solution within the Open Telekom Cloud environment. Loki integrates seamlessly with Grafana to collect, index, and visualize log data without the high storage costs associated with traditional log management systems. By running Loki on CCE, users can take advantage of Kubernetes-native deployments, simplified scaling, and secure, managed infrastructure. This approach provides an efficient foundation for observability, supporting modern DevOps practices and improving operational insights across distributed applications."]}),"\n",(0,t.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,t.jsxs)(n.p,{children:["Grafana Loki is built around a modular architecture that separates log ingestion, storage, and querying to achieve scalability and cost efficiency. When logs are collected from applications or system components, they are first received by the ",(0,t.jsx)(n.strong,{children:"distributor"}),", which authenticates and validates the data before ",(0,t.jsx)(n.em,{children:"routing"})," it to the ",(0,t.jsx)(n.strong,{children:"ingesters"}),". The ingesters ",(0,t.jsx)(n.em,{children:"temporarily hold log streams in memory"}),", compress them into chunks, and then ",(0,t.jsx)(n.em,{children:"push these chunks to long-term storage"})," such as S3 or in our case, Open Telekom Cloud Object Storage (OBS). At the same time, they write small index files that map log labels to their corresponding chunks, stored either in a key-value database or alongside the chunks in object storage."]}),"\n",(0,t.jsxs)(n.p,{children:["When a user runs a query from Grafana or directly through the Loki API, the querier reads the index to locate the relevant chunks, retrieves them from storage, and returns the combined results. In larger or production setups, a ",(0,t.jsx)(n.strong,{children:"query frontend"})," can be added to optimize performance by caching and parallelizing requests. This division of responsibilities\u2014distributors for routing, ingesters for writing, and queriers for reading, ensures Loki remains efficient even at scale. On Cloud Container Engine (CCE), this architecture integrates naturally with Kubernetes, providing a reliable and cost-effective platform for log aggregation and analysis."]}),"\n",(0,t.jsx)("center",{children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"image",src:i(22180).A+"",width:"1615",height:"904"})})}),"\n",(0,t.jsxs)(n.p,{children:["For more information, consult the official ",(0,t.jsx)(n.a,{href:"https://grafana.com/docs/loki/latest/get-started/architecture/",children:"Loki architecture"})," documentation."]}),"\n",(0,t.jsx)(n.h2,{id:"installing-grafana-loki",children:"Installing Grafana Loki"}),"\n",(0,t.jsx)(n.p,{children:"Installing Grafana Loki on Cloud Container Engine (CCE) using Helm is the most straightforward and flexible deployment approach. The Helm chart provided by Grafana supports several deployment modes, allowing users to tailor the setup to their operational needs and cluster scale."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"https://grafana.com/docs/loki/latest/get-started/deployment-modes/#monolithic-mode",children:"monolithic"})," mode deploys Loki as a single process that combines all core components\u2014distributor, ingester, querier, and compactor\u2014into one service. This variant is ideal for small environments, test setups, or single-tenant use cases where simplicity and ease of management are more important than high scalability."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"https://grafana.com/docs/loki/latest/get-started/deployment-modes/#simple-scalable",children:"simple scalable"})," variation provides a middle ground, offering some degree of component separation and scalability without the full complexity of the distributed deployment. It\u2019s often used in medium-sized environments or early production stages."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["And finally, the ",(0,t.jsx)(n.a,{href:"https://grafana.com/docs/loki/latest/get-started/deployment-modes/#microservices-mode",children:"microservices"})," mode (also referred in the past as the distributed mode) separates Loki\u2019s components into individual services. Each component can scale independently, offering higher performance and fault tolerance. This setup suits production workloads and larger clusters where log volume and query traffic vary significantly."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"In this blueprint, Loki will be deployed on Cloud Container Engine (CCE) in microservices mode as it is the only one that provides the flexibility and performance needed for large production-grade environments where reliability and throughput are critical. For backend storage, the deployment will use Open Telekom Cloud Object Storage (OBS)."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"image",src:i(98985).A+"",width:"1299",height:"856"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Go to ",(0,t.jsx)(n.em,{children:"Open Telekom Cloud Console"})," -> ",(0,t.jsx)(n.em,{children:"Object Storage Service"})," and click ",(0,t.jsx)(n.em,{children:"Create Bucket"})," to create an OBS bucket for Loki."]}),"\n",(0,t.jsxs)(n.admonition,{type:"note",children:[(0,t.jsxs)(n.p,{children:["A single bucket is sufficient for ",(0,t.jsx)(n.a,{href:"https://grafana.com/docs/loki/latest/operations/storage/boltdb-shipper/",children:"boltdb-shipper"})," or ",(0,t.jsx)(n.a,{href:"https://grafana.com/docs/loki/latest/operations/storage/tsdb/",children:"TSDB"})," modes."]}),(0,t.jsxs)(n.p,{children:["\ud83d\udccc"," Enable versioning to protect against accidental deletes during compaction.",(0,t.jsx)(n.br,{}),"\n","\ud83d\udccc"," Keep the bucket private."]})]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Optionally"}),", if no access key pair exists, open the ",(0,t.jsx)(n.em,{children:"Open Telekom Cloud Console"})," -> ",(0,t.jsx)(n.em,{children:"Identity & Access Management (IAM)"}),". In the IAM dashboard, select ",(0,t.jsx)(n.em,{children:"Users"}),", choose the user you intend to work with, and open the ",(0,t.jsx)(n.em,{children:"Security Settings"})," tab. Scroll down to the ",(0,t.jsx)(n.em,{children:"Access Keys"})," section and select ",(0,t.jsx)(n.em,{children:"Create Access Key"})," to generate a new Access Key and Secret Key pair."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Create a namespace and provision the Access Key and Secret Key pair as a Kubernetes Secret:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kubectl create namespace monitoring\n\nkubectl -n monitoring create secret generic loki-obs-credentials \\\n--from-literal=S3_ACCESS_KEY_ID='<ACCESS_KEY>' \\\n--from-literal=S3_SECRET_ACCESS_KEY='<SECRET_KEY>' \\\n--from-literal=S3_REGION='<REGION>'\n"})}),"\n",(0,t.jsxs)(n.p,{children:["or alternatively create a manifest called, ",(0,t.jsx)(n.strong,{children:"loki-obs-credentials.yaml"}),", and apply it with ",(0,t.jsx)(n.strong,{children:"kubectl"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'title="loki-obs-credentials.yaml"',children:'apiVersion: v1\nkind: Secret\nmetadata:\n    name: loki-obs-credentials\n    namespace: monitoring\ntype: Opaque\nstringData:\n    S3_ACCESS_KEY_ID: "<ACCESS_KEY>"\n    S3_SECRET_ACCESS_KEY: "<SECRET_KEY>"\n    S3_REGION: "<REGION>"\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"important",children:(0,t.jsxs)(n.p,{children:["Loki\u2019s S3 client supports the use of static credentials. To prevent exposing sensitive information in the Helm values file, these credentials are stored in a Kubernetes Secret. The environment variables use the ",(0,t.jsx)(n.code,{children:"S3_"})," prefix, following the naming conventions of the S3 SDK. Replace the placeholder values with your own access key (AK) and secret key (SK). In this blueprint, all resources will be deployed in the ",(0,t.jsx)(n.code,{children:"eu-de"})," region, which will be used as the default region throughout the setup."]})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Next, we need to prepare the Helm chart override values, namely ",(0,t.jsx)(n.strong,{children:"values-loki-obs.yaml"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'title="values-loki-obs.yaml"',children:'deploymentMode: Distributed\n\nglobal:\n    dnsService: "coredns"\n\nloki:\n    auth_enabled: false\n\n    schemaConfig:\n        configs:\n        - from: "2024-01-01"\n            store: tsdb\n            object_store: s3\n            schema: v13\n            index:\n                prefix: loki_index_\n                period: 24h\n\n    storage:\n        type: s3\n        bucketNames:\n            chunks: loki\n            ruler: loki\n            admin: loki\n        s3:\n            endpoint: obs.eu-de.otc.t-systems.com\n            region: ${S3_REGION}\n            accessKeyId: ${S3_ACCESS_KEY_ID}\n            secretAccessKey: ${S3_SECRET_ACCESS_KEY}\n            s3ForcePathStyle: true\n\n    limits_config:\n        ingestion_rate_mb: 8\n        ingestion_burst_size_mb: 16\n        max_query_series: 200000\n        max_global_streams_per_user: 5000\n        reject_old_samples: true\n        reject_old_samples_max_age: 72h\n        retention_period: 30d\n\n    compactor:\n        retention_enabled: true\n        delete_request_store: s3\n        compaction_interval: 5m\n        delete_request_cancel_period: 24h\n\nbackend: { replicas: 0 }\nread:    { replicas: 0 }\nwrite:   { replicas: 0 }\nsingleBinary: { replicas: 0 }\n\ngateway:\n    enabled: true\n    replicas: 1\n    service:\n        type: ClusterIP\n        port: 80\n    extraEnvFrom:\n        - secretRef: { name: loki-obs-credentials }\n    extraArgs:\n        - -config.expand-env=true\n    resources:\n        requests: { cpu: 50m,  memory: 128Mi }\n        limits:   { cpu: 200m, memory: 256Mi }\n\ndistributor:\n    replicas: 2\n    maxUnavailable: 1\n    extraEnvFrom:\n        - secretRef: { name: loki-obs-credentials }\n    extraArgs:\n        - -config.expand-env=true  \n    resources:\n        requests: { cpu: 100m, memory: 256Mi }\n        limits:   { cpu: "1",  memory: 512Mi }\n\ningester:\n    replicas: 3\n    maxUnavailable: 1\n    extraEnvFrom:\n        - secretRef: { name: loki-obs-credentials }\n    extraArgs:\n        - -config.expand-env=true\n        - -ingester.wal-enabled=true\n    resources:\n        requests: { cpu: 500m, memory: 2Gi }\n        limits:   { cpu: "2",  memory: 4Gi }\n    persistence:\n        enabled: true\n        accessModes: ["ReadWriteOnce"]\n        size: 20Gi    \n        storageClass: csi-disk  \n\nindexGateway:\n    replicas: 2\n    maxUnavailable: 1\n    extraEnvFrom:\n        - secretRef: { name: loki-obs-credentials }\n    extraArgs:\n        - -config.expand-env=true\n    resources:\n        requests: { cpu: 200m, memory: 1Gi }\n        limits:   { cpu: "1",  memory: 2Gi }\n    persistence:\n        enabled: true\n        accessModes: ["ReadWriteOnce"]\n        size: 10Gi\n        storageClass: csi-disk  \n\nquerier:\n    replicas: 2\n    maxUnavailable: 1\n    extraEnvFrom:\n        - secretRef: { name: loki-obs-credentials }\n    extraArgs:\n        - -config.expand-env=true\n    resources:\n        requests: { cpu: 200m, memory: 1Gi }\n        limits:   { cpu: "1",  memory: 2Gi }\n\nqueryFrontend:\n    replicas: 2\n    maxUnavailable: 1\n    extraEnvFrom:\n        - secretRef: { name: loki-obs-credentials }\n    extraArgs:\n        - -config.expand-env=true\n    resources:\n        requests: { cpu: 100m, memory: 256Mi }\n        limits:   { cpu: 500m, memory: 512Mi }\n\nqueryScheduler:\n    replicas: 2\n    maxUnavailable: 1\n    extraEnvFrom:\n        - secretRef: { name: loki-obs-credentials }\n    extraArgs:\n        - -config.expand-env=true\n    resources:\n        requests: { cpu: 100m, memory: 256Mi }\n        limits:   { cpu: 500m, memory: 512Mi }\n\nruler:\n    enabled: true\n    replicas: 1\n    extraEnvFrom:\n        - secretRef: { name: loki-obs-credentials }\n    extraArgs:\n        - -config.expand-env=true\n    resources:\n        requests: { cpu: 100m, memory: 512Mi }\n        limits:   { cpu: 500m, memory: 1Gi }\n    persistence:\n        enabled: true\n        accessModes: ["ReadWriteOnce"]\n        size: 2Gi\n        storageClass: csi-disk  \n\ncompactor:\n    replicas: 1\n    extraEnvFrom:\n        - secretRef: { name: loki-obs-credentials }\n    extraArgs:\n        - -config.expand-env=true\n    resources:\n        requests: { cpu: 200m, memory: 1Gi }\n        limits:   { cpu: "1",  memory: 2Gi }\n    persistence:\n        enabled: true\n        accessModes: ["ReadWriteOnce"]\n        size: 10Gi\n        storageClass: csi-disk  \n\nmemberlist:\n    service:\n        publishNotReadyAddresses: true\n\nmonitoring:\n    serviceMonitor: { enabled: false }\n    selfMonitoring: { enabled: false }\n\npodSecurityContext: { fsGroup: 10001 }\nsecurityContext:\n    runAsNonRoot: true\n    runAsUser: 10001\n    runAsGroup: 10001\n    allowPrivilegeEscalation: false\n'})}),"\n",(0,t.jsxs)(n.admonition,{type:"important",children:[(0,t.jsx)(n.p,{children:"The key points to note from this configuration are:"}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"deploymentMode: Distributed"}),", dictates Loki to run in a fully distributed architecture, where each core component\u2014such as the distributor, ingester, and querier\u2014operates as a separate service. This enables independent scaling, better performance, and higher resilience, making it suitable for production environments."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"schemaConfig.configs.store: tsdb"}),", tells Loki to use the ",(0,t.jsx)(n.a,{href:"https://grafana.com/docs/loki/latest/operations/storage/tsdb/",children:"TSDB"})," (Time Series Database) format for storing log data. This modern storage engine improves query performance, compaction, and index management compared to older backends, and is the recommended option for recent Loki versions."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"storage.type: s3"})," setting defines S3-compatible object storage as Loki\u2019s backend for storing log chunks. The ",(0,t.jsx)(n.code,{children:"storage.s3"})," section provides the connection details\u2014such as endpoint, bucket name, and credentials\u2014needed for Loki to write and read data from that storage. Make sure you adjust the ",(0,t.jsx)(n.code,{children:"storage.s3.endpoint"})," and ",(0,t.jsx)(n.code,{children:"storage.bucketNames.*"})," values according to the properties of the OBS bucket we provisioned in the previous step."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"global.dnsService: coredns"}),", defines the DNS service Loki uses for internal name resolution within the Kubernetes cluster. Setting it explicitly to ",(0,t.jsx)(n.code,{children:"coredns"})," ensures compatibility with the default DNS setup in most modern Kubernetes distributions, one of them CCE. If this value is not specified, Loki defaults to using ",(0,t.jsx)(n.code,{children:"kube-dns"}),"."]}),"\n"]}),"\n"]}),(0,t.jsxs)(n.p,{children:["For deeper understanding of the configuration values of the Helm chart for this deployment mode refer to the official guide: ",(0,t.jsx)(n.a,{href:"https://grafana.com/docs/loki/latest/setup/install/helm/install-microservices/",children:"Install the microservice Helm chart"}),"."]})]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"And finally, we need to deploy the Helm chart:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"helm repo add grafana https://grafana.github.io/helm-charts\nhelm repo update\n\nhelm upgrade --install loki grafana/loki \\\n-f values-loki-obs.yaml \\\n-n monitoring --create-namespace \\\n--reset-values\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"warning",children:(0,t.jsxs)(n.p,{children:["Ensure that you select the ",(0,t.jsx)(n.code,{children:"grafana/loki"})," chart from the Helm repository, as this is the current version that supports deployment in microservices mode. ",(0,t.jsx)(n.strong,{children:"Do not"})," use ",(0,t.jsx)(n.code,{children:"grafana/loki-distributed"}),", which is deprecated and no longer maintained and replaced by ",(0,t.jsx)(n.code,{children:"grafana/loki"}),"."]})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"verification",children:"Verification"}),"\n",(0,t.jsxs)(n.p,{children:["If the deployment was successful, you should see multiple pods running in the ",(0,t.jsx)(n.code,{children:"monitoring"})," namespace:"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"image",src:i(94856).A+"",width:"1914",height:"887"})}),"\n",(0,t.jsxs)(n.p,{children:["along with the ",(0,t.jsx)(n.strong,{children:"loki_cluster_seed.json"})," file created in your OBS bucket:"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"image",src:i(50430).A+"",width:"1901",height:"850"})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.strong,{children:"loki_cluster_seed.json"})," file is a metadata file generated by Loki to help manage and identify the state of the cluster. It contains information such as the cluster\u2019s unique identifier, deployment configuration, and references to index and storage metadata. This file acts as a seed record that allows Loki components to coordinate and recognize each other during startup or recovery. In setups using object storage, such as Open Telekom Cloud OBS, the file is stored in the bucket defined for Loki\u2019s backend and ensures consistent initialization of the cluster after restarts or scaling events."]})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},94856:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/Screenshot_from_2025-10-09_09-51-13-b4f808dcf47177b25e2f4732fab78e63.png"},50430:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/Screenshot_from_2025-10-09_10-07-54-11ae80d1e54030342b0e54dddd454635.png"},22180:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/loki-architecture-62adbb29e60472a3a8782f6ec5b4b2f0.png"},98985:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/microservices-mode-54c2cfc17e812689f67e1abdda5b67b5.png"},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var s=i(96540);const t={},r=s.createContext(t);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);