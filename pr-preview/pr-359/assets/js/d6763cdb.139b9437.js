"use strict";(self.webpackChunkdocs_next=self.webpackChunkdocs_next||[]).push([[22950],{17757:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>g,frontMatter:()=>l,metadata:()=>t,toc:()=>u});const t=JSON.parse('{"id":"best-practices/containers/cloud-container-engine/enabling-external-traffic-with-ingress-and-tls","title":"Enabling External Traffic with Ingress & TLS","description":"Before deploying our workloads, the CCE cluster must be equipped with a set of foundational components. In this section, we\'ll install and configure essential prerequisites such as the NGINX Ingress Controller for routing external traffic, cert-manager for managing TLS certificates, and other supporting workloads. These components establish the baseline infrastructure required to expose services securely and ensure smooth operation of the application stack within the Kubernetes environment.","source":"@site/docs/best-practices/containers/cloud-container-engine/enabling-external-traffic-with-ingress-and-tls.mdx","sourceDirName":"best-practices/containers/cloud-container-engine","slug":"/best-practices/containers/cloud-container-engine/enabling-external-traffic-with-ingress-and-tls","permalink":"/docs-next/pr-preview/pr-359/docs/best-practices/containers/cloud-container-engine/enabling-external-traffic-with-ingress-and-tls","draft":false,"unlisted":false,"editUrl":"https://github.com/opentelekomcloud/docs-next/tree/main/docs/best-practices/containers/cloud-container-engine/enabling-external-traffic-with-ingress-and-tls.mdx","tags":[{"inline":true,"label":"cce","permalink":"/docs-next/pr-preview/pr-359/docs/tags/cce"},{"inline":true,"label":"elb","permalink":"/docs-next/pr-preview/pr-359/docs/tags/elb"},{"inline":true,"label":"externaldns","permalink":"/docs-next/pr-preview/pr-359/docs/tags/externaldns"},{"inline":true,"label":"dns","permalink":"/docs-next/pr-preview/pr-359/docs/tags/dns"},{"inline":true,"label":"nginx","permalink":"/docs-next/pr-preview/pr-359/docs/tags/nginx"},{"inline":true,"label":"acme","permalink":"/docs-next/pr-preview/pr-359/docs/tags/acme"},{"inline":true,"label":"ingress","permalink":"/docs-next/pr-preview/pr-359/docs/tags/ingress"},{"inline":true,"label":"cert-manager","permalink":"/docs-next/pr-preview/pr-359/docs/tags/cert-manager"}],"version":"current","frontMatter":{"id":"enabling-external-traffic-with-ingress-and-tls","title":"Enabling External Traffic with Ingress & TLS","tags":["cce","elb","externaldns","dns","nginx","acme","ingress","cert-manager"]},"sidebar":"bestPracticesSidebar","previous":{"title":"Cloud Container Engine","permalink":"/docs-next/pr-preview/pr-359/docs/best-practices/containers/cloud-container-engine"},"next":{"title":"Automate DNS Records Creation from CCE Ingresses with ExternalDNS","permalink":"/docs-next/pr-preview/pr-359/docs/best-practices/containers/cloud-container-engine/automate-dns-records-creation-from-cce-ingresses-with-externaldns"}}');var s=r(74848),i=r(28453),a=r(11470),o=r(19365);const l={id:"enabling-external-traffic-with-ingress-and-tls",title:"Enabling External Traffic with Ingress & TLS",tags:["cce","elb","externaldns","dns","nginx","acme","ingress","cert-manager"]},c="Enabling External Traffic with Ingress & TLS",d={},u=[{value:"Ingress Overview",id:"ingress-overview",level:2},{value:"Configuring your registar",id:"configuring-your-registar",level:2},{value:"Installing NGINX Ingress Controller",id:"installing-nginx-ingress-controller",level:2},{value:"Configuring an Elastic Load Balancer",id:"configuring-an-elastic-load-balancer",level:3},{value:"Deploying NGINX Ingress Controller",id:"deploying-nginx-ingress-controller",level:3},{value:"Installing OTC ACME DNS01 Solver",id:"installing-otc-acme-dns01-solver",level:2},{value:"Appendix",id:"appendix",level:2}];function h(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"enabling-external-traffic-with-ingress--tls",children:"Enabling External Traffic with Ingress & TLS"})}),"\n",(0,s.jsx)(n.p,{children:"Before deploying our workloads, the CCE cluster must be equipped with a set of foundational components. In this section, we'll install and configure essential prerequisites such as the NGINX Ingress Controller for routing external traffic, cert-manager for managing TLS certificates, and other supporting workloads. These components establish the baseline infrastructure required to expose services securely and ensure smooth operation of the application stack within the Kubernetes environment."}),"\n",(0,s.jsx)(n.h2,{id:"ingress-overview",children:"Ingress Overview"}),"\n",(0,s.jsx)(n.p,{children:"Kubernetes uses ingress resources to define how incoming traffic should be handled, while the Ingress Controller is responsible for processing the actual traffic."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Ingress object: a set of access rules that forward requests to specified Services based on domain names or paths. It can be added, deleted, modified, and queried by calling APIs."}),"\n",(0,s.jsx)(n.li,{children:"Ingress Controller: an executor for forwarding requests. It monitors the changes of resource objects such as ingresses, Services, endpoints, secrets (mainly TLS certificates and keys), nodes, and ConfigMaps in real time, parses rules defined by ingresses, and forwards requests to the target backend Services."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The way of implementing Ingress Controllers varies depending on their vendors. CCE supports ",(0,s.jsx)(n.strong,{children:"LoadBalancer Ingress Controllers"})," and ",(0,s.jsx)(n.strong,{children:"NGINX Ingress Controllers"}),"."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"LoadBalancer Ingress Controllers are deployed on master nodes and forward traffic based on the ELB. All policy configurations and forwarding behaviors are managed on the ELB."}),"\n",(0,s.jsx)(n.li,{children:"NGINX Ingress Controllers are deployed in clusters using charts and images maintained by the Kubernetes community. They provide external access through NodePort and forward external traffic to other services in the cluster through Nginx. All traffic forwarding behaviors and forwarding objects are within the cluster."}),"\n"]}),"\n",(0,s.jsxs)(n.admonition,{type:"important",children:[(0,s.jsxs)(n.p,{children:["In this Best Practice, we will enable external traffic using ",(0,s.jsx)(n.strong,{children:"NGINX Ingress Controllers"}),"."]}),(0,s.jsxs)(n.p,{children:["For a deeper understanding of their differences, refer to the comprehensive ",(0,s.jsx)(n.a,{href:"https://docs.otc.t-systems.com/cloud-container-engine/umn/networking/ingresses/ingress_overview.html#ingress-feature-comparison",children:"feature comparison list"}),"\nin Open Telekom Cloud Help Center."]})]}),"\n",(0,s.jsx)(n.h2,{id:"configuring-your-registar",children:"Configuring your registar"}),"\n",(0,s.jsx)(n.p,{children:"We have to transfer the management of the NS-Records of your domain to the Domain Name Service of Open Telekom Cloud. Go on the site of your registar and make sure you configure the following:"}),"\n",(0,s.jsxs)(n.p,{children:["Turn off any Dynamic DNS service for the domain or the subdomains you are going to bind with Open Telekom Cloud DNS.\nChange the NS-Records of your domain or the subdomains to point to",":ns1",".open-telekom-cloud.com and ns2.open-telekom-cloud.com"]}),"\n",(0,s.jsxs)(n.p,{children:["Once the nameserver changes have propagated and Open Telekom Cloud DNS service assumes authoritative control of your domain, you can proceed to define DNS zones and records.\nFrom here (assuming you have already created a ",(0,s.jsx)(n.em,{children:"Public DNS Zone"})," in the Open Telekom Cloud DNS service for you domain), you have two options depending on your operational approach:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Manual Configuration"}),(0,s.jsx)(n.br,{}),"\n","Create an ",(0,s.jsx)(n.strong,{children:"A record"})," that links the desired FQDN for each workload (e.g., ",(0,s.jsx)(n.code,{children:"application.example.com"}),") to the ",(0,s.jsx)(n.strong,{children:"EIP"})," of the external load balancer you provision manually."]}),"\n",(0,s.jsx)(n.admonition,{type:"important",children:(0,s.jsxs)(n.p,{children:["This step must be performed ",(0,s.jsx)(n.strong,{children:"for each individual workload"}),"."]})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Automated Configuration with ExternalDNS"}),(0,s.jsx)(n.br,{}),"\n","Deploy the ExternalDNS in your Kubernetes cluster. It watches Ingress resources (among others such as CRDs and Services) and automatically creates or updates DNS records in your Open Telekom Cloud DNS zone according to annotations in these resources. This approach is well-suited for dynamic environments or production setups that leverage infrastructure-as-code and minimize manual management. Follow the instructions of ",(0,s.jsx)(n.a,{href:"../cloud-container-engine/automate-dns-records-creation-from-cce-ingresses-with-externaldns",children:"Automate DNS Records Creation from CCE Ingresses with ExternalDNS"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"installing-nginx-ingress-controller",children:"Installing NGINX Ingress Controller"}),"\n",(0,s.jsx)(n.h3,{id:"configuring-an-elastic-load-balancer",children:"Configuring an Elastic Load Balancer"}),"\n","\n",(0,s.jsxs)(a.A,{children:[(0,s.jsxs)(o.A,{value:"manual-elb",label:"Manual Configuration of Elastic Load Balancer",default:!0,children:[(0,s.jsx)(n.admonition,{type:"caution",children:(0,s.jsxs)(n.p,{children:["This step has to take place ",(0,s.jsx)(n.strong,{children:"once"})," for every cluster as long as you are planning to use a single load balancer for all of your workloads."]})}),(0,s.jsx)(n.p,{children:"The first step in preparing the environment is to provision an Elastic Load Balancer (ELB), which will serve as the external entry point for traffic into the CCE cluster. Setting up an ELB setup is critical for handling external traffic and forwarding requests to services within the cluster, such as the Ingress Controller."}),(0,s.jsxs)(n.p,{children:["Go to ",(0,s.jsx)(n.em,{children:"Open Telekom Cloud Console"})," -> ",(0,s.jsx)(n.em,{children:"Network"})," -> ",(0,s.jsx)(n.em,{children:"Elastic Load Balancing"})," and click ",(0,s.jsx)(n.em,{children:"Create Elastic Load Balancer"}),". Ensure that the Elastic Load Balancer is provisioned within the same VPC and Subnet as your CCE cluster. This network alignment is essential to allow the load balancer to reach the CCE worker nodes directly using their private IP addresses. Misplacing the ELB in a different network segment would result in unreachable backends and broken ingress routing."]}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"image",src:r(9521).A+"",width:"1333",height:"671"})}),(0,s.jsxs)(n.p,{children:["After the Elastic Load Balancer is provisioned, make sure to record the ELB ",(0,s.jsx)(n.em,{children:"ID"}),". This unique identifier is needed when configuring the NGINX Ingress Controller, enabling it to correctly bind to the external load balancer and manage incoming traffic. The ELB ID acts as a reference to link Kubernetes resources with the underlying network infrastructure, ensuring smooth integration between your Ingress layer and the public-facing endpoint."]}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"image",src:r(62589).A+"",width:"2758",height:"926"})})]}),(0,s.jsx)(o.A,{value:"automatic-elb",label:"Automatic Configuration of Elastic Load Balancer",children:(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:"You dont need to do anything in this case, the Elastic Load Balancer will be created by the NGINX Ingress Controller annotations."})})})]}),"\n",(0,s.jsx)(n.h3,{id:"deploying-nginx-ingress-controller",children:"Deploying NGINX Ingress Controller"}),"\n",(0,s.jsx)(n.admonition,{type:"caution",children:(0,s.jsxs)(n.p,{children:["This step only needs to be performed ",(0,s.jsx)(n.strong,{children:"once per cluster"}),", if you plan to use a single load balancer for all workloads."]})}),"\n",(0,s.jsxs)(n.p,{children:["In this step, we'll deploy the ",(0,s.jsx)(n.a,{href:"https://github.com/kubernetes/ingress-nginx",children:"Ingress NGINX Controller for Kubernetes"}),", which serves as the bridge between the Elastic Load Balancer and the services running within the CCE cluster. The controller manages HTTP(S) routing and termination, directing external traffic to the correct internal services based on host and path rules."]}),"\n","\n",(0,s.jsxs)(n.p,{children:["To deploy the NGINX Ingress Controller for Kubernetes correctly, we provide Helm with a custom values file, typically named ",(0,s.jsx)(n.strong,{children:"overrides.yaml"}),", that specifies configuration parameters for the deployment."]}),"\n",(0,s.jsxs)(a.A,{children:[(0,s.jsxs)(o.A,{value:"manual-elb",label:"Manual Configuration of Elastic Load Balancer",default:!0,children:[(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"kubernetes.io/elb.id"})," annotation is applied to the ",(0,s.jsx)(n.code,{children:"Service"})," resource created by the NGINX Ingress Controller for Kubernetes, ensuring that all ",(0,s.jsx)(n.code,{children:"Ingress"})," resources using this ",(0,s.jsx)(n.code,{children:"IngressClass"})," ",(0,s.jsx)(n.strong,{children:"are automatically associated with the specified load balancer"}),":"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",metastring:'title="overrides.yaml" ',children:'controller:\n  replicaCount: 1\n  service:\n    externalTrafficPolicy: Cluster\n    annotations:\n      kubernetes.io/elb.id: "<ELB_ID>"\n'})}),(0,s.jsx)(n.admonition,{type:"important",children:(0,s.jsxs)(n.p,{children:["Be sure to replace placeholder value ",(0,s.jsx)(n.code,{children:"<ELB_ID>"})," with the actual ID of the Elastic Load Balancer created earlier."]})})]}),(0,s.jsxs)(o.A,{value:"automatic-elb",label:"Automatic Configuration of Elastic Load Balancer",children:[(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",metastring:'title="overrides.yaml" ',children:'controller:\n  replicaCount: 1\n  service:\n    externalTrafficPolicy: Cluster\n    annotations:\n      kubernetes.io/elb.class: performance\n      kubernetes.io/elb.http-redirect: "true"\n      kubernetes.io/elb.listen-ports: \'[{"HTTP": 80},{"HTTPS": 443}]\'\n      kubernetes.io/elb.autocreate: \'{\n        "type": "public",\n        "bandwidth_name": "cce-bandwidth-nginx-ingress",\n        "bandwidth_chargemode": "traffic",\n        "bandwidth_size": 5,\n        "bandwidth_sharetype": "PER",\n        "eip_type": "5_bgp",\n        "l7_flavor_name": "L7_flavor.elb.s1.small",\n        "available_zone": [ "eu-de-01" ]\n      }\'\n'})}),(0,s.jsxs)(n.admonition,{title:"very important",type:"danger",children:[(0,s.jsxs)(n.p,{children:["If you are in the ",(0,s.jsx)(n.code,{children:"eu-nl"})," region, be sure to:"]}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Update the ",(0,s.jsx)(n.code,{children:"available_zone"})," to ",(0,s.jsx)(n.code,{children:"eu-nl-01"})," and/or ",(0,s.jsx)(n.code,{children:"eu-nl-02"})]}),"\n",(0,s.jsxs)(n.li,{children:["Add the annotation ",(0,s.jsx)(n.code,{children:'"l4_flavor_name": "L4_flavor.elb.s1.small"'})]}),"\n"]}),(0,s.jsxs)(n.p,{children:["For a deeper understanding on how to use ingress annotations to specify the ELB class, enable HTTP->HTTPS redirection,\ndefine listener ports, and even instruct Open Telekom Cloud to automatically create a public or private ELB with a specific bandwidth,\nflavor, and availability zone refer to\n",(0,s.jsx)(n.a,{href:"https://docs.otc.t-systems.com/cloud-container-engine/umn/networking/services/loadbalancer/configuring_advanced_load_balancing_functions_using_annotations.html",children:"Configuring Advanced Load Balancing Functions Using Annotations"}),"."]})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["Once the ",(0,s.jsx)(n.strong,{children:"overrides.yaml"})," file is ready, you can install the NGINX Ingress Controller using Helm. This will deploy all necessary components into a dedicated namespace called ",(0,s.jsx)(n.code,{children:"nginx-system"}),". Execute the following commands:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx\nhelm repo update\n\nhelm upgrade --install nginx-ingress ingress-nginx/ingress-nginx \\\n  --namespace nginx-system \\\n  --create-namespace \\\n  --values overrides.yaml\n\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This will set up the Ingress NGINX Controller for Kubernetes with your custom configuration, including the ELB binding. Once deployed, Kubernetes Ingress resources referencing the ",(0,s.jsx)(n.code,{children:"nginx"})," class will route traffic through this controller."]}),"\n",(0,s.jsx)(n.h2,{id:"installing-otc-acme-dns01-solver",children:"Installing OTC ACME DNS01 Solver"}),"\n",(0,s.jsx)(n.admonition,{type:"caution",children:(0,s.jsxs)(n.p,{children:["This step only needs to be performed ",(0,s.jsx)(n.strong,{children:"once per cluster"}),"."]})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://cert-manager.io/",children:"Cert-manager"})," DNS providers are integrations with various DNS (Domain Name System) service providers that allow cert-manager, a Kubernetes add-on, to automate the management of SSL/TLS certificates. DNS providers enable cert-manager to automatically perform challenges to prove domain ownership and obtain certificates from certificate authorities like Let's Encrypt."]}),"\n",(0,s.jsx)(n.p,{children:"By configuring cert-manager with the compatible Open Telekom Cloud DNS provider, we can set up automatic certificate issuance and renewal for our Open Telekom Cloud CCE workloads without manual intervention. This automation is crucial for securing web applications and services deployed on CCE clusters."}),"\n",(0,s.jsxs)(n.p,{children:["To enable automated TLS provisioning for workloads in your CCE cluster, follow the recommended approach for as in the Best Practice: ",(0,s.jsx)(n.a,{href:"/docs/best-practices/containers/cloud-container-engine/issue-an-acme-certificate-with-dns01-solver-in-cce",children:"Issue an ACME Certificate with DNS01 Solver in CCE"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"appendix",children:"Appendix"}),"\n",(0,s.jsx)(n.admonition,{title:"Useful Links",type:"tip",children:(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://docs.otc.t-systems.com/cloud-container-engine/umn/networking/ingresses/ingress_overview.html#ingress-feature-comparison",children:"CCE Ingresses Feature Comparison"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://docs.otc.t-systems.com/cloud-container-engine/umn/networking/ingresses/nginx_ingresses/configuring_advanced_nginx_ingress_functions_using_annotations.html",children:"Configuring Advanced Nginx Ingress Functions Using Annotations"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://docs.otc.t-systems.com/cloud-container-engine/umn/networking/ingresses/nginx_ingresses/advanced_setting_examples_of_nginx_ingresses/nginx_ingress_usage_suggestions.html",children:"Nginx Ingress Usage Suggestions"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://docs.otc.t-systems.com/cloud-container-engine/umn/networking/ingresses/nginx_ingresses/advanced_setting_examples_of_nginx_ingresses/optimizing_nginx_ingress_controller_in_high-traffic_scenarios.html",children:"Optimizing NGINX Ingress Controller in High-Traffic Scenarios"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://docs.otc.t-systems.com/cloud-container-engine/umn/networking/services/loadbalancer/configuring_advanced_load_balancing_functions_using_annotations.html",children:"Configuring Advanced Load Balancing Functions Using Annotations"})}),"\n"]})})]})}function g(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},19365:(e,n,r)=>{r.d(n,{A:()=>a});r(96540);var t=r(34164);const s={tabItem:"tabItem_Ymn6"};var i=r(74848);function a({children:e,hidden:n,className:r}){return(0,i.jsx)("div",{role:"tabpanel",className:(0,t.A)(s.tabItem,r),hidden:n,children:e})}},11470:(e,n,r)=>{r.d(n,{A:()=>C});var t=r(96540),s=r(34164),i=r(17559),a=r(23104),o=r(56347),l=r(205),c=r(57485),d=r(31682),u=r(89466);function h(e){return t.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,t.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function g(e){const{values:n,children:r}=e;return(0,t.useMemo)((()=>{const e=n??function(e){return h(e).map((({props:{value:e,label:n,attributes:r,default:t}})=>({value:e,label:n,attributes:r,default:t})))}(r);return function(e){const n=(0,d.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,r])}function p({value:e,tabValues:n}){return n.some((n=>n.value===e))}function m({queryString:e=!1,groupId:n}){const r=(0,o.W6)(),s=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,c.aZ)(s),(0,t.useCallback)((e=>{if(!s)return;const n=new URLSearchParams(r.location.search);n.set(s,e),r.replace({...r.location,search:n.toString()})}),[s,r])]}function f(e){const{defaultValue:n,queryString:r=!1,groupId:s}=e,i=g(e),[a,o]=(0,t.useState)((()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!p({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const r=n.find((e=>e.default))??n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:i}))),[c,d]=m({queryString:r,groupId:s}),[h,f]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[r,s]=(0,u.Dv)(n);return[r,(0,t.useCallback)((e=>{n&&s.set(e)}),[n,s])]}({groupId:s}),x=(()=>{const e=c??h;return p({value:e,tabValues:i})?e:null})();(0,l.A)((()=>{x&&o(x)}),[x]);return{selectedValue:a,selectValue:(0,t.useCallback)((e=>{if(!p({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);o(e),d(e),f(e)}),[d,f,i]),tabValues:i}}var x=r(92303);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var v=r(74848);function w({className:e,block:n,selectedValue:r,selectValue:t,tabValues:i}){const o=[],{blockElementScrollPositionUntilNextRender:l}=(0,a.a_)(),c=e=>{const n=e.currentTarget,s=o.indexOf(n),a=i[s].value;a!==r&&(l(n),t(a))},d=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const r=o.indexOf(e.currentTarget)+1;n=o[r]??o[0];break}case"ArrowLeft":{const r=o.indexOf(e.currentTarget)-1;n=o[r]??o[o.length-1];break}}n?.focus()};return(0,v.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":n},e),children:i.map((({value:e,label:n,attributes:t})=>(0,v.jsx)("li",{role:"tab",tabIndex:r===e?0:-1,"aria-selected":r===e,ref:e=>{o.push(e)},onKeyDown:d,onClick:c,...t,className:(0,s.A)("tabs__item",b.tabItem,t?.className,{"tabs__item--active":r===e}),children:n??e},e)))})}function j({lazy:e,children:n,selectedValue:r}){const i=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=i.find((e=>e.props.value===r));return e?(0,t.cloneElement)(e,{className:(0,s.A)("margin-top--md",e.props.className)}):null}return(0,v.jsx)("div",{className:"margin-top--md",children:i.map(((e,n)=>(0,t.cloneElement)(e,{key:n,hidden:e.props.value!==r})))})}function y(e){const n=f(e);return(0,v.jsxs)("div",{className:(0,s.A)(i.G.tabs.container,"tabs-container",b.tabList),children:[(0,v.jsx)(w,{...n,...e}),(0,v.jsx)(j,{...n,...e})]})}function C(e){const n=(0,x.A)();return(0,v.jsx)(y,{...e,children:h(e.children)},String(n))}},62589:(e,n,r)=>{r.d(n,{A:()=>t});const t=r.p+"assets/images/SCR-20231211-i88-b8344560a68f1ec85b2c88ba65f160c0.png"},9521:(e,n,r)=>{r.d(n,{A:()=>t});const t=r.p+"assets/images/Screenshot_from_2025-04-16_08-06-28-91d4325003db9a426ecce6dc9ae7e2a3.png"},28453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var t=r(96540);const s={},i=t.createContext(s);function a(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);