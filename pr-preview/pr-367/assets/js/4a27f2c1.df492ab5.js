"use strict";(self.webpackChunkdocs_next=self.webpackChunkdocs_next||[]).push([[85259],{14681:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>g,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/by-use-case/observability/aggregate-cce-logs-with-grafana-alloy-and-grafana-loki","title":"Aggregate CCE Logs with Grafana Alloy & Grafana Loki","description":"This blueprint explains how to collect and centralize logs from Cloud Container Engine (CCE) using Grafana Alloy and Grafana Loki. It outlines the process of configuring Grafana Alloy as a unified telemetry collector within Kubernetes and integrating it with Grafana Loki for efficient storage and visualization. By the end, you will have a modern, future-proof, and scalable logging setup that simplifies monitoring, troubleshooting, and operational insights across your CCE workloads.","source":"@site/docs/blueprints/by-use-case/observability/aggregate-cce-logs-with-grafana-alloy-and-grafana-loki.md","sourceDirName":"blueprints/by-use-case/observability","slug":"/blueprints/by-use-case/observability/aggregate-cce-logs-with-grafana-alloy-and-grafana-loki","permalink":"/docs-next/pr-preview/pr-367/docs/blueprints/by-use-case/observability/aggregate-cce-logs-with-grafana-alloy-and-grafana-loki","draft":false,"unlisted":false,"editUrl":"https://github.com/opentelekomcloud/docs-next/tree/main/docs/blueprints/by-use-case/observability/aggregate-cce-logs-with-grafana-alloy-and-grafana-loki.md","tags":[{"inline":true,"label":"cce","permalink":"/docs-next/pr-preview/pr-367/docs/tags/cce"},{"inline":true,"label":"observability","permalink":"/docs-next/pr-preview/pr-367/docs/tags/observability"},{"inline":true,"label":"logging","permalink":"/docs-next/pr-preview/pr-367/docs/tags/logging"},{"inline":true,"label":"grafana","permalink":"/docs-next/pr-preview/pr-367/docs/tags/grafana"},{"inline":true,"label":"loki","permalink":"/docs-next/pr-preview/pr-367/docs/tags/loki"},{"inline":true,"label":"alloy","permalink":"/docs-next/pr-preview/pr-367/docs/tags/alloy"}],"version":"current","sidebarPosition":4,"frontMatter":{"id":"aggregate-cce-logs-with-grafana-alloy-and-grafana-loki","title":"Aggregate CCE Logs with Grafana Alloy & Grafana Loki","tags":["cce","observability","logging","grafana","loki","alloy"],"sidebar_position":4},"sidebar":"blueprintsSidebar","previous":{"title":"Aggregate CCE Logs with Fluent Bit & Grafana Loki","permalink":"/docs-next/pr-preview/pr-367/docs/blueprints/by-use-case/observability/aggregate-cce-logs-with-fluentbit-and-grafana-loki"},"next":{"title":"Migrating from Promtail to Grafana Alloy","permalink":"/docs-next/pr-preview/pr-367/docs/blueprints/by-use-case/observability/migrate-from-promtail-to-grafana-alloy"}}');var t=a(74848),l=a(28453);const i={id:"aggregate-cce-logs-with-grafana-alloy-and-grafana-loki",title:"Aggregate CCE Logs with Grafana Alloy & Grafana Loki",tags:["cce","observability","logging","grafana","loki","alloy"],sidebar_position:4},r="Aggregate CCE Logs with Grafana Alloy & Grafana Loki",s={},c=[{value:"What is Grafana Alloy?",id:"what-is-grafana-alloy",level:2},{value:"Why Choose Grafana Alloy?",id:"why-choose-grafana-alloy",level:2},{value:"Installing Grafana Loki",id:"installing-grafana-loki",level:2},{value:"Installing Grafana Alloy",id:"installing-grafana-alloy",level:2},{value:"Configuring Grafana Alloy for CCE Log Collection",id:"configuring-grafana-alloy-for-cce-log-collection",level:3},{value:"Understanding the Alloy Configuration",id:"understanding-the-alloy-configuration",level:3},{value:"Installing Grafana Alloy via Helm",id:"installing-grafana-alloy-via-helm",level:3},{value:"Verifying the Installation",id:"verifying-the-installation",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"aggregate-cce-logs-with-grafana-alloy--grafana-loki",children:"Aggregate CCE Logs with Grafana Alloy & Grafana Loki"})}),"\n",(0,t.jsxs)(n.p,{children:["This blueprint explains how to collect and centralize logs from Cloud Container Engine (CCE) using ",(0,t.jsx)(n.a,{href:"https://grafana.com/docs/alloy/latest/",children:"Grafana Alloy"})," and ",(0,t.jsx)(n.a,{href:"https://grafana.com/oss/loki/",children:"Grafana Loki"}),". It outlines the process of configuring Grafana Alloy as a unified telemetry collector within Kubernetes and integrating it with Grafana Loki for efficient storage and visualization. By the end, you will have a modern, future-proof, and scalable logging setup that simplifies monitoring, troubleshooting, and operational insights across your CCE workloads."]}),"\n",(0,t.jsx)(n.h2,{id:"what-is-grafana-alloy",children:"What is Grafana Alloy?"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"image",src:a(96138).A+"",width:"1200",height:"387"})}),"\n",(0,t.jsxs)(n.p,{children:["Grafana Alloy is a flexible, high-performance, vendor-neutral telemetry Collector. It also replaces ",(0,t.jsx)(n.a,{href:"https://grafana.com/docs/loki/latest/send-data/promtail/",children:"Promtail"})," as the actively maintained log collection agent. Alloy is fully compatible with popular open source observability standards such as ",(0,t.jsx)(n.a,{href:"https://opentelemetry.io/",children:"OpenTelemetry"})," and ",(0,t.jsx)(n.a,{href:"https://prometheus.io/",children:"Prometheus"}),", focusing on ease of use and the ability to adapt to the needs of power users."]}),"\n",(0,t.jsx)(n.p,{children:'Unlike Promtail, which was designed solely for log collection, Alloy is a unified telemetry collector that natively supports all observability signals including logs, metrics, traces, and profiles. This "big tent" approach means you can deploy a single agent per node instead of managing multiple specialized collectors.'}),"\n",(0,t.jsx)(n.p,{children:"Grafana Loki serves as a log aggregation system optimized for scalability, availability, and cost efficiency. Drawing inspiration from Prometheus, Loki indexes only metadata through labels rather than the log content itself. Loki groups log entries into streams and indexes them with labels, which reduces overall costs and the time between log entry ingestion and query availability."}),"\n",(0,t.jsx)(n.h2,{id:"why-choose-grafana-alloy",children:"Why Choose Grafana Alloy?"}),"\n",(0,t.jsxs)(n.p,{children:["Grafana Alloy represents the future of telemetry collection in the Grafana ecosystem. Its unified approach to collecting logs, metrics, traces, and profiles reduces operational complexity while providing enterprise-grade features like clustering, GitOps support, and advanced debugging capabilities. With ",(0,t.jsx)(n.a,{href:"https://grafana.com/docs/loki/latest/send-data/promtail/",children:"Promtail reaching end-of-life in March 2026"}),", migrating to Alloy ensures your logging infrastructure remains supported and gains access to ongoing feature development."]}),"\n",(0,t.jsx)(n.p,{children:"The component-based architecture provides flexibility to adapt to changing requirements without replacing the entire collector. Whether you're collecting simple container logs or building complex observability pipelines with multiple data sources and destinations, Alloy's extensibility and OpenTelemetry-native design future-proof your investment."}),"\n",(0,t.jsx)(n.h2,{id:"installing-grafana-loki",children:"Installing Grafana Loki"}),"\n",(0,t.jsxs)(n.p,{children:["If you don't already have a Grafana Loki instance running, you can set it up first before proceeding with log aggregation. The installation process is covered in detail in the companion blueprint ",(0,t.jsx)(n.a,{href:"/docs/blueprints/by-use-case/observability/deploy-grafana-loki-on-cce",children:"Deploy Grafana Loki on CCE"}),", which explains how to deploy Loki in microservices mode on Cloud Container Engine (CCE) with Open Telekom Cloud Object Storage (OBS) as the backend. Once Loki is up and running, you can continue here to install and configure Grafana Alloy and start collecting and centralizing logs from your CCE workloads."]}),"\n",(0,t.jsx)(n.h2,{id:"installing-grafana-alloy",children:"Installing Grafana Alloy"}),"\n",(0,t.jsx)(n.h3,{id:"configuring-grafana-alloy-for-cce-log-collection",children:"Configuring Grafana Alloy for CCE Log Collection"}),"\n",(0,t.jsx)(n.p,{children:"Create a ConfigMap for Alloy's configuration. This will be referenced in the Helm values file."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'title="alloy-configmap.yaml"',children:'apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: alloy-logs-config\n  namespace: monitoring\ndata:\n  config: |\n    // Discover all pods in the cluster\n    discovery.kubernetes "pods" {\n      role = "pod"\n      \n      // Restrict to pods on the same node to reduce resource usage\n      selectors {\n        role = "pod"\n        field = "spec.nodeName=" + coalesce(sys.env("HOSTNAME"), constants.hostname)\n      }\n\n      // This attaches node metadata to pod targets\n      attach_metadata {\n        node = true  \n      }\n    }\n\n\n    // Relabel discovered pods and create file paths\n    discovery.relabel "pod_logs" {\n      targets = discovery.kubernetes.pods.targets\n      \n      // Extract namespace\n      rule {\n        source_labels = ["__meta_kubernetes_namespace"]\n        action = "replace"\n        target_label = "namespace"\n      }\n      \n      // Extract pod name\n      rule {\n        source_labels = ["__meta_kubernetes_pod_name"]\n        action = "replace"\n        target_label = "pod"\n      }\n      \n      // Extract container name\n      rule {\n        source_labels = ["__meta_kubernetes_pod_container_name"]\n        action = "replace"\n        target_label = "container"\n      }\n\n      // Add region label from node\n      rule {\n        source_labels = ["__meta_kubernetes_node_label_topology_kubernetes_io_region"]\n        target_label  = "region"\n      }\n      \n      // Add availability zone label from node\n      rule {\n        source_labels = ["__meta_kubernetes_node_label_topology_kubernetes_io_zone"]\n        target_label  = "zone"\n      }\n      \n      // Create job label from namespace/container\n      rule {\n        source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_pod_container_name"]\n        action = "replace"\n        target_label = "job"\n        separator = "/"\n        replacement = "$1"\n      }\n      \n      // Extract app label if it exists\n      rule {\n        source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]\n        action = "replace"\n        target_label = "app"\n      }\n      \n      // Create file path for pod logs\n      rule {\n        source_labels = ["__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]\n        action = "replace"\n        target_label = "__path__"\n        separator = "/"\n        replacement = "/var/log/pods/*$1/*.log"\n      }\n      \n      // Extract container runtime\n      rule {\n        source_labels = ["__meta_kubernetes_pod_container_id"]\n        action = "replace"\n        target_label = "tmp_container_runtime"\n        regex = "^(\\\\w+):\\\\/\\\\/.+$"\n        replacement = "$1"\n      }\n      \n      // Drop pods with no container ID (not yet running)\n      rule {\n        source_labels = ["__meta_kubernetes_pod_container_id"]\n        action = "drop"\n        regex = ""\n      }\n    }\n\n\n    // Match actual log files on disk\n    local.file_match "pod_logs" {\n      path_targets = discovery.relabel.pod_logs.output\n    }\n\n\n    // Read logs from files\n    loki.source.file "pod_logs" {\n      targets = local.file_match.pod_logs.targets\n      forward_to = [loki.process.pod_logs.receiver]\n    }\n\n\n    // Process and enrich logs\n    loki.process "pod_logs" {\n      \n      // Parse containerd/CRI-O logs\n      stage.match {\n        selector = "{tmp_container_runtime=\\"containerd\\"}"\n        \n        stage.cri {}\n        \n        // Extract stream label (stdout or stderr)\n        stage.labels {\n          values = {\n            stream = "",\n          }\n        }\n      }\n      \n      \n      // Add static labels like cluster identifier\n      stage.static_labels {\n        values = {\n          cluster = "production",\n        }\n      }\n      \n      // Drop temporary labels\n      stage.label_drop {\n        values = ["tmp_container_runtime", "filename"]\n      }\n      \n      forward_to = [loki.write.default.receiver]\n    }\n\n    // Write configuration - sends logs to Loki\n    loki.write "default" {\n      endpoint {\n        url = "http://loki-gateway.monitoring.svc.cluster.local/loki/api/v1/push"\n      }\n      \n      // External labels applied to all logs\n      external_labels = {\n        aggregator = "alloy",\n      }\n    }\n\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"important",children:(0,t.jsx)(n.p,{children:"This is a baseline configuration and you may need to adjust it based on your specific environment and requirements."})}),"\n",(0,t.jsx)(n.admonition,{title:"Node Metadata for Geographic Labels",type:"tip",children:(0,t.jsxs)(n.p,{children:["By setting ",(0,t.jsx)(n.code,{children:"attach_metadata {node = true}"}),", Alloy attaches node-level metadata to pod targets, which enables extraction of ",(0,t.jsx)(n.strong,{children:"availability zone"})," and ",(0,t.jsx)(n.strong,{children:"region"})," labels in the subsequent relabeling rules. This is useful for multi-region deployments and debugging location-specific issues."]})}),"\n",(0,t.jsx)(n.p,{children:"Then apply the ConfigMap:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kubectl apply -f alloy-configmap.yaml\n"})}),"\n",(0,t.jsx)(n.h3,{id:"understanding-the-alloy-configuration",children:"Understanding the Alloy Configuration"}),"\n",(0,t.jsxs)(n.p,{children:["The Alloy ",(0,t.jsx)(n.a,{href:"https://grafana.com/docs/alloy/latest/reference/config-blocks/",children:"configuration"})," uses a ",(0,t.jsx)(n.a,{href:"https://grafana.com/docs/alloy/latest/reference/components/",children:"component-based"})," approach where each component performs a specific task and forwards data to the next component in the pipeline."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Discovery Components"}),": The ",(0,t.jsx)(n.code,{children:"discovery.kubernetes"})," component discovers pods in the cluster, while ",(0,t.jsx)(n.code,{children:"discovery.relabel"})," filters and labels the discovered targets. This is similar to Prometheus service discovery but integrated directly into the collector."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Source Component"}),": The ",(0,t.jsx)(n.code,{children:"loki.source"})," component reads log files from the discovered pod targets and forwards them to the processing stage."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Processing Pipeline"}),": The ",(0,t.jsx)(n.code,{children:"loki.process"})," component applies multiple stages to transform and enrich the logs. It parses CRI format, extracts JSON fields, handles timestamps, and creates labels."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Write Component"}),": The ",(0,t.jsx)(n.code,{children:"loki.write"})," component sends the processed logs to Loki with configurable batching, retry, and timeout settings."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"installing-grafana-alloy-via-helm",children:"Installing Grafana Alloy via Helm"}),"\n",(0,t.jsxs)(n.p,{children:["Now create a values file called ",(0,t.jsx)(n.strong,{children:"values-alloy.yaml"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'title="values-alloy.yaml"',children:"alloy:\n  # Use a ConfigMap for configuration\n  configMap:\n    create: false\n    name: alloy-logs-config\n    key: config\n  \n  # Should be disabled when using DaemonSet as controller\n  clustering:\n    enabled: false  # Enable for high availability\n  \n  # Mount host paths for log collection\n  mounts:\n    # Mount /var/log for pod logs\n    varlog: true  \n    # On CCE, containerd logs are under /var/lib/containerd/container_logs and should be mounted explicitly\n    extra:\n      - name: containerd-logs\n        mountPath: /var/lib/containerd/container_logs\n        readOnly: true\n\n  # Resource limits for production\n  resources:\n    limits:\n      cpu: 1000m\n      memory: 1Gi\n    requests:\n      cpu: 500m\n      memory: 512Mi\n  \n  # Security context required for reading pod logs\n  securityContext:\n    privileged: true\n    runAsUser: 0 \n    runAsGroup: 0\n    fsGroup: 0\n  \n  # Extra environment variables for selecting based on node name\n  extraEnv:\n    - name: HOSTNAME\n      valueFrom:\n        fieldRef:\n          fieldPath: spec.nodeName\n\n# Deploy as DaemonSet\ncontroller:\n  type: 'daemonset'\n  volumes:\n    extra:\n      - name: containerd-logs\n        hostPath:\n          path: /var/lib/containerd/container_logs\n  \n  # Update strategy\n  updateStrategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 1\n  \n# Service account settings\nserviceAccount:\n  create: true\n\n# RBAC permissions\nrbac:\n  create: true\n"})}),"\n",(0,t.jsx)(n.admonition,{title:"Log Collection Methods",type:"note",children:(0,t.jsx)(n.p,{children:"Alloy supports collecting logs through the Kubernetes API server instead of mounting host paths. This approach doesn't require privileged security contexts and can be useful for development or environments with strict security policies. However, for production systems, directly mounting log directories is recommended as it provides better performance by removing the log request load from the Kubernetes API server."})}),"\n",(0,t.jsx)(n.admonition,{title:"CCE Containerd Log Path",type:"danger",children:(0,t.jsxs)(n.p,{children:["On CCE, containerd stores container logs at ",(0,t.jsx)(n.code,{children:"/var/lib/containerd/container_logs"}),". The standard ",(0,t.jsx)(n.code,{children:"/var/log/pods"})," path is a symbolic link to that path. You must explicitly mount this directory in your Alloy DaemonSet configuration (as shown in the ",(0,t.jsx)(n.code,{children:"mounts.extra"})," section above) to ensure all container logs are collected. Without this mount, logs from containerd-based containers will not be accessible to Alloy."]})}),"\n",(0,t.jsx)(n.p,{children:"Deploy Grafana Alloy via Helm:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"helm repo add grafana https://grafana.github.io/helm-charts\nhelm repo update\n\nhelm upgrade --install alloy grafana/alloy \\\n  -f values-alloy.yaml \\\n  -n monitoring --create-namespace \\\n  --reset-values\n"})}),"\n",(0,t.jsx)(n.h3,{id:"verifying-the-installation",children:"Verifying the Installation"}),"\n",(0,t.jsx)(n.p,{children:"After deploying Alloy, verify that it's collecting and forwarding logs correctly."}),"\n",(0,t.jsx)(n.p,{children:"First, check that all Alloy pods are running:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kubectl get pods -n monitoring -l app.kubernetes.io/name=alloy\n"})}),"\n",(0,t.jsxs)(n.p,{children:["All pods should show a ",(0,t.jsx)(n.strong,{children:"Running"})," status. Next, access the Alloy UI by port-forwarding to one of the pods:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kubectl port-forward -n monitoring daemonset/alloy 12345:12345\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Open your browser and navigate to ",(0,t.jsx)(n.code,{children:"http://localhost:12345"}),". In the Alloy UI:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Click on ",(0,t.jsx)(n.strong,{children:"Graph"})," to view the component pipeline visualization"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"image",src:a(85891).A+"",width:"1408",height:"756"})}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:["Click on ",(0,t.jsx)(n.strong,{children:"Alloy logo"})," to get list of defined components and verify that all components show a green status indicator"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"image",src:a(21369).A+"",width:"1365",height:"738"})}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsxs)(n.li,{children:["Click on the ",(0,t.jsx)(n.code,{children:"loki.source.file"})," component to see active targets and log files being read"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["To confirm logs are arriving in Loki, navigate to ",(0,t.jsx)(n.strong,{children:"Grafana"})," and run a simple query in ",(0,t.jsx)(n.strong,{children:"Explore"})," or view the ",(0,t.jsx)(n.strong,{children:"Drilldown"})," section:"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"image",src:a(4507).A+"",width:"1411",height:"886"})}),"\n",(0,t.jsxs)(n.p,{children:["You should see logs from pods. If logs appear with labels like ",(0,t.jsx)(n.code,{children:"pod"}),", ",(0,t.jsx)(n.code,{children:"namespace"}),", ",(0,t.jsx)(n.code,{children:"container"}),", ",(0,t.jsx)(n.code,{children:"region"}),", and ",(0,t.jsx)(n.code,{children:"zone"}),", your Alloy configuration is working correctly. If no logs appear, check the Alloy component details for error messages and verify that the Loki endpoint URL is correct in your configuration."]})]})}function g(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},85891:(e,n,a)=>{a.d(n,{A:()=>o});const o=a.p+"assets/images/grafana-alloy-dashboard-graph-bdb562e2d216a696405d02499115cadc.png"},21369:(e,n,a)=>{a.d(n,{A:()=>o});const o=a.p+"assets/images/grafana-alloy-dashboard-status-214212caa64b5ca7f2c6c4620e58ff0d.png"},4507:(e,n,a)=>{a.d(n,{A:()=>o});const o=a.p+"assets/images/grafana-alloy-grafana-dashboard-15596e1ecb0592ee1d814e16ad467d6e.png"},96138:(e,n,a)=>{a.d(n,{A:()=>o});const o=a.p+"assets/images/grfana-alloy-overview-75a1ab5930b0228a3cb1147fef24abd6.png"},28453:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>r});var o=a(96540);const t={},l=o.createContext(t);function i(e){const n=o.useContext(l);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),o.createElement(l.Provider,{value:n},e.children)}}}]);